// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by lokstra-annotation from annotations in this folder
// Annotations: @RouterService, @Inject, @Route

package application

import (
	"github.com/primadi/lokstra/core/deploy"
	"github.com/primadi/lokstra/core/proxy"
	"github.com/primadi/lokstra/lokstra_registry"
	"github.com/primadi/lokstra/core/service"
	domain "github.com/primadi/lokstra-auth/00_core/domain"
	repository "github.com/primadi/lokstra-auth/00_core/infrastructure/repository"
	request "github.com/primadi/lokstra/core/request"
)

// Auto-register on package import
func init() {
	RegisterAppKeyService()
	RegisterAppService()
	RegisterBranchService()
	RegisterCredentialConfigService()
	RegisterTenantService()
	RegisterUserService()
}


// ============================================================
// FILE: app_key_service.go
// ============================================================

// AppKeyServiceRemote implements AppKeyServiceInterface with HTTP proxy
// Auto-generated from AppKeyService interface methods
type AppKeyServiceRemote struct {
	proxyService *proxy.Service
}

// NewAppKeyServiceRemote creates a new remote app-key-service proxy
func NewAppKeyServiceRemote(proxyService *proxy.Service) *AppKeyServiceRemote {
	return &AppKeyServiceRemote{
		proxyService: proxyService,
	}
}


// DeleteKey via HTTP
// Generated from: @Route "DELETE /{key_id}"
func (s *AppKeyServiceRemote) DeleteKey(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteKey", p)
}


// GenerateKey via HTTP
// Generated from: @Route "POST /"
func (s *AppKeyServiceRemote) GenerateKey(p *request.Context) (*domain.AppKeyResponse, error) {
	return proxy.CallWithData[*domain.AppKeyResponse](s.proxyService, "GenerateKey", p)
}


// GetKey via HTTP
// Generated from: @Route "GET /{key_id}"
func (s *AppKeyServiceRemote) GetKey(p *request.Context) (*domain.AppKeyInfo, error) {
	return proxy.CallWithData[*domain.AppKeyInfo](s.proxyService, "GetKey", p)
}


// ListKeys via HTTP
// Generated from: @Route "GET /"
func (s *AppKeyServiceRemote) ListKeys(p *request.Context) ([]*domain.AppKeyInfo, error) {
	return proxy.CallWithData[[]*domain.AppKeyInfo](s.proxyService, "ListKeys", p)
}


// RevokeKey via HTTP
// Generated from: @Route "POST /{key_id}/revoke"
func (s *AppKeyServiceRemote) RevokeKey(p *request.Context) error {
	return proxy.Call(s.proxyService, "RevokeKey", p)
}


// RotateKey via HTTP
// Generated from: @Route "POST /{key_id}/rotate"
func (s *AppKeyServiceRemote) RotateKey(p *request.Context) (*domain.AppKeyResponse, error) {
	return proxy.CallWithData[*domain.AppKeyResponse](s.proxyService, "RotateKey", p)
}



func AppKeyServiceFactory(deps map[string]any, config map[string]any) any {
	return &AppKeyService{
		Store: service.Cast[repository.AppKeyStore](deps["app-key-store"]),
		AppService: service.Cast[*AppService](deps["app-service"]),
	}
}

// AppKeyServiceRemoteFactory creates a remote HTTP client for AppKeyServiceInterface
// Auto-generated from @RouterService annotation
func AppKeyServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAppKeyServiceRemote(proxyService)
}

// RegisterAppKeyService registers the app-key-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="app-key-service", prefix="/api/registration/tenants/{tenant_id}/apps/{app_id}/keys"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterAppKeyService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("app-key-service-factory",
		AppKeyServiceFactory,
		AppKeyServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/registration/tenants/{tenant_id}/apps/{app_id}/keys",
			Middlewares: []string{ "recovery", "request-logger" },
			CustomRoutes: map[string]string{
				"DeleteKey":  "DELETE /{key_id}",
				"GenerateKey":  "POST /",
				"GetKey":  "GET /{key_id}",
				"ListKeys":  "GET /",
				"RevokeKey":  "POST /{key_id}/revoke",
				"RotateKey":  "POST /{key_id}/rotate",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("app-key-service",
		"app-key-service-factory",
		map[string]any{
			"depends-on": []string{ "app-key-store", "app-service",  },
		})
}

// ============================================================
// FILE: app_service.go
// ============================================================

// AppServiceRemote implements AppServiceInterface with HTTP proxy
// Auto-generated from AppService interface methods
type AppServiceRemote struct {
	proxyService *proxy.Service
}

// NewAppServiceRemote creates a new remote app-service proxy
func NewAppServiceRemote(proxyService *proxy.Service) *AppServiceRemote {
	return &AppServiceRemote{
		proxyService: proxyService,
	}
}


// ActivateApp via HTTP
// Generated from: @Route "POST /{id}/activate"
func (s *AppServiceRemote) ActivateApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "ActivateApp", p)
}


// CreateApp via HTTP
// Generated from: @Route "POST /"
func (s *AppServiceRemote) CreateApp(p *request.Context) (*domain.App, error) {
	return proxy.CallWithData[*domain.App](s.proxyService, "CreateApp", p)
}


// DeleteApp via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *AppServiceRemote) DeleteApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteApp", p)
}


// GetApp via HTTP
// Generated from: @Route "GET /{id}"
func (s *AppServiceRemote) GetApp(p *request.Context) (*domain.App, error) {
	return proxy.CallWithData[*domain.App](s.proxyService, "GetApp", p)
}


// ListAppUsers via HTTP
// Generated from: @Route "GET /{app_id}/users"
func (s *AppServiceRemote) ListAppUsers(p *request.Context) ([]string, error) {
	return proxy.CallWithData[[]string](s.proxyService, "ListAppUsers", p)
}


// ListApps via HTTP
// Generated from: @Route "GET /"
func (s *AppServiceRemote) ListApps(p *request.Context) ([]*domain.App, error) {
	return proxy.CallWithData[[]*domain.App](s.proxyService, "ListApps", p)
}


// SuspendApp via HTTP
// Generated from: @Route "POST /{id}/suspend"
func (s *AppServiceRemote) SuspendApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "SuspendApp", p)
}


// UpdateApp via HTTP
// Generated from: @Route "PUT /{id}"
func (s *AppServiceRemote) UpdateApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "UpdateApp", p)
}



func AppServiceFactory(deps map[string]any, config map[string]any) any {
	return &AppService{
		Store: service.Cast[repository.AppStore](deps["app-store"]),
		TenantService: service.Cast[*TenantService](deps["tenant-service"]),
		UserAppStore: service.Cast[repository.UserAppStore](deps["user-app-store"]),
	}
}

// AppServiceRemoteFactory creates a remote HTTP client for AppServiceInterface
// Auto-generated from @RouterService annotation
func AppServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAppServiceRemote(proxyService)
}

// RegisterAppService registers the app-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="app-service", prefix="/api/registration/tenants/{tenant_id}/apps"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterAppService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("app-service-factory",
		AppServiceFactory,
		AppServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/registration/tenants/{tenant_id}/apps",
			Middlewares: []string{ "recovery", "request-logger" },
			CustomRoutes: map[string]string{
				"ActivateApp":  "POST /{id}/activate",
				"CreateApp":  "POST /",
				"DeleteApp":  "DELETE /{id}",
				"GetApp":  "GET /{id}",
				"ListAppUsers":  "GET /{app_id}/users",
				"ListApps":  "GET /",
				"SuspendApp":  "POST /{id}/suspend",
				"UpdateApp":  "PUT /{id}",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("app-service",
		"app-service-factory",
		map[string]any{
			"depends-on": []string{ "app-store", "tenant-service", "user-app-store",  },
		})
}

// ============================================================
// FILE: branch_service.go
// ============================================================

// BranchServiceRemote implements BranchServiceInterface with HTTP proxy
// Auto-generated from BranchService interface methods
type BranchServiceRemote struct {
	proxyService *proxy.Service
}

// NewBranchServiceRemote creates a new remote branch-service proxy
func NewBranchServiceRemote(proxyService *proxy.Service) *BranchServiceRemote {
	return &BranchServiceRemote{
		proxyService: proxyService,
	}
}


// ActivateBranch via HTTP
// Generated from: @Route "POST /{id}/activate"
func (s *BranchServiceRemote) ActivateBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "ActivateBranch", p)
}


// CreateBranch via HTTP
// Generated from: @Route "POST /"
func (s *BranchServiceRemote) CreateBranch(p *request.Context) (*domain.Branch, error) {
	return proxy.CallWithData[*domain.Branch](s.proxyService, "CreateBranch", p)
}


// DeleteBranch via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *BranchServiceRemote) DeleteBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteBranch", p)
}


// DisableBranch via HTTP
// Generated from: @Route "POST /{id}/disable"
func (s *BranchServiceRemote) DisableBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "DisableBranch", p)
}


// GetBranch via HTTP
// Generated from: @Route "GET /{id}"
func (s *BranchServiceRemote) GetBranch(p *request.Context) (*domain.Branch, error) {
	return proxy.CallWithData[*domain.Branch](s.proxyService, "GetBranch", p)
}


// ListBranches via HTTP
// Generated from: @Route "GET /"
func (s *BranchServiceRemote) ListBranches(p *request.Context) ([]*domain.Branch, error) {
	return proxy.CallWithData[[]*domain.Branch](s.proxyService, "ListBranches", p)
}


// UpdateBranch via HTTP
// Generated from: @Route "PUT /{id}"
func (s *BranchServiceRemote) UpdateBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "UpdateBranch", p)
}



func BranchServiceFactory(deps map[string]any, config map[string]any) any {
	return &BranchService{
		AppService: service.Cast[*AppService](deps["app-service"]),
		Store: service.Cast[repository.BranchStore](deps["branch-store"]),
	}
}

// BranchServiceRemoteFactory creates a remote HTTP client for BranchServiceInterface
// Auto-generated from @RouterService annotation
func BranchServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewBranchServiceRemote(proxyService)
}

// RegisterBranchService registers the branch-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="branch-service", prefix="/api/registration/tenants/{tenant_id}/apps/{app_id}/branches"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterBranchService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("branch-service-factory",
		BranchServiceFactory,
		BranchServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/registration/tenants/{tenant_id}/apps/{app_id}/branches",
			Middlewares: []string{ "recovery", "request-logger" },
			CustomRoutes: map[string]string{
				"ActivateBranch":  "POST /{id}/activate",
				"CreateBranch":  "POST /",
				"DeleteBranch":  "DELETE /{id}",
				"DisableBranch":  "POST /{id}/disable",
				"GetBranch":  "GET /{id}",
				"ListBranches":  "GET /",
				"UpdateBranch":  "PUT /{id}",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("branch-service",
		"branch-service-factory",
		map[string]any{
			"depends-on": []string{ "app-service", "branch-store",  },
		})
}

// ============================================================
// FILE: credential_config_service.go
// ============================================================

// CredentialConfigServiceRemote implements CredentialConfigServiceInterface with HTTP proxy
// Auto-generated from CredentialConfigService interface methods
type CredentialConfigServiceRemote struct {
	proxyService *proxy.Service
}

// NewCredentialConfigServiceRemote creates a new remote credential-config-service proxy
func NewCredentialConfigServiceRemote(proxyService *proxy.Service) *CredentialConfigServiceRemote {
	return &CredentialConfigServiceRemote{
		proxyService: proxyService,
	}
}


// GetAppConfig via HTTP
// Generated from: @Route "GET /tenants/{tenant_id}/apps/{app_id}"
func (s *CredentialConfigServiceRemote) GetAppConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "GetAppConfig", p)
}


// GetTenantConfig via HTTP
// Generated from: @Route "GET /tenants/{tenant_id}"
func (s *CredentialConfigServiceRemote) GetTenantConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "GetTenantConfig", p)
}


// UpdateAppConfig via HTTP
// Generated from: @Route "PUT /tenants/{tenant_id}/apps/{app_id}"
func (s *CredentialConfigServiceRemote) UpdateAppConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "UpdateAppConfig", p)
}


// UpdateTenantConfig via HTTP
// Generated from: @Route "PUT /tenants/{tenant_id}"
func (s *CredentialConfigServiceRemote) UpdateTenantConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "UpdateTenantConfig", p)
}



func CredentialConfigServiceFactory(deps map[string]any, config map[string]any) any {
	return &CredentialConfigService{
		AppService: service.Cast[*AppService](deps["app-service"]),
		TenantService: service.Cast[*TenantService](deps["tenant-service"]),
	}
}

// CredentialConfigServiceRemoteFactory creates a remote HTTP client for CredentialConfigServiceInterface
// Auto-generated from @RouterService annotation
func CredentialConfigServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewCredentialConfigServiceRemote(proxyService)
}

// RegisterCredentialConfigService registers the credential-config-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="credential-config-service", prefix="/api/registration/config/credentials"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterCredentialConfigService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("credential-config-service-factory",
		CredentialConfigServiceFactory,
		CredentialConfigServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/registration/config/credentials",
			Middlewares: []string{ "recovery", "request-logger" },
			CustomRoutes: map[string]string{
				"GetAppConfig":  "GET /tenants/{tenant_id}/apps/{app_id}",
				"GetTenantConfig":  "GET /tenants/{tenant_id}",
				"UpdateAppConfig":  "PUT /tenants/{tenant_id}/apps/{app_id}",
				"UpdateTenantConfig":  "PUT /tenants/{tenant_id}",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("credential-config-service",
		"credential-config-service-factory",
		map[string]any{
			"depends-on": []string{ "app-service", "tenant-service",  },
		})
}

// ============================================================
// FILE: tenant_service.go
// ============================================================

// TenantServiceRemote implements TenantServiceInterface with HTTP proxy
// Auto-generated from TenantService interface methods
type TenantServiceRemote struct {
	proxyService *proxy.Service
}

// NewTenantServiceRemote creates a new remote tenant-service proxy
func NewTenantServiceRemote(proxyService *proxy.Service) *TenantServiceRemote {
	return &TenantServiceRemote{
		proxyService: proxyService,
	}
}


// ActivateTenant via HTTP
// Generated from: @Route "POST /{id}/activate"
func (s *TenantServiceRemote) ActivateTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "ActivateTenant", p)
}


// CreateTenant via HTTP
// Generated from: @Route "POST /"
func (s *TenantServiceRemote) CreateTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "CreateTenant", p)
}


// DeleteTenant via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *TenantServiceRemote) DeleteTenant(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteTenant", p)
}


// GetTenant via HTTP
// Generated from: @Route "GET /{id}"
func (s *TenantServiceRemote) GetTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "GetTenant", p)
}


// ListTenants via HTTP
// Generated from: @Route "GET /"
func (s *TenantServiceRemote) ListTenants(p *request.Context) ([]*domain.Tenant, error) {
	return proxy.CallWithData[[]*domain.Tenant](s.proxyService, "ListTenants", p)
}


// SuspendTenant via HTTP
// Generated from: @Route "POST /{id}/suspend"
func (s *TenantServiceRemote) SuspendTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "SuspendTenant", p)
}


// UpdateTenant via HTTP
// Generated from: @Route "PUT /{id}"
func (s *TenantServiceRemote) UpdateTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "UpdateTenant", p)
}



func TenantServiceFactory(deps map[string]any, config map[string]any) any {
	return &TenantService{
		Store: service.Cast[repository.TenantStore](deps["tenant-store"]),
	}
}

// TenantServiceRemoteFactory creates a remote HTTP client for TenantServiceInterface
// Auto-generated from @RouterService annotation
func TenantServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewTenantServiceRemote(proxyService)
}

// RegisterTenantService registers the tenant-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="tenant-service", prefix="/api/registration/tenants"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterTenantService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("tenant-service-factory",
		TenantServiceFactory,
		TenantServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/registration/tenants",
			Middlewares: []string{ "recovery", "request-logger" },
			CustomRoutes: map[string]string{
				"ActivateTenant":  "POST /{id}/activate",
				"CreateTenant":  "POST /",
				"DeleteTenant":  "DELETE /{id}",
				"GetTenant":  "GET /{id}",
				"ListTenants":  "GET /",
				"SuspendTenant":  "POST /{id}/suspend",
				"UpdateTenant":  "PUT /{id}",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("tenant-service",
		"tenant-service-factory",
		map[string]any{
			"depends-on": []string{ "tenant-store",  },
		})
}

// ============================================================
// FILE: user_service.go
// ============================================================

// UserServiceRemote implements UserServiceInterface with HTTP proxy
// Auto-generated from UserService interface methods
type UserServiceRemote struct {
	proxyService *proxy.Service
}

// NewUserServiceRemote creates a new remote user-service proxy
func NewUserServiceRemote(proxyService *proxy.Service) *UserServiceRemote {
	return &UserServiceRemote{
		proxyService: proxyService,
	}
}


// ActivateUser via HTTP
// Generated from: @Route "POST /{id}/activate"
func (s *UserServiceRemote) ActivateUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "ActivateUser", p)
}


// AssignUserToApp via HTTP
// Generated from: @Route "POST /{user_id}/assign-app"
func (s *UserServiceRemote) AssignUserToApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "AssignUserToApp", p)
}


// CreateUser via HTTP
// Generated from: @Route "POST /"
func (s *UserServiceRemote) CreateUser(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "CreateUser", p)
}


// DeleteUser via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *UserServiceRemote) DeleteUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteUser", p)
}


// GetUser via HTTP
// Generated from: @Route "GET /{id}"
func (s *UserServiceRemote) GetUser(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "GetUser", p)
}


// GetUserByEmail via HTTP
// Generated from: @Route "GET /by-email/{email}"
func (s *UserServiceRemote) GetUserByEmail(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "GetUserByEmail", p)
}


// GetUserByUsername via HTTP
// Generated from: @Route "GET /by-username/{username}"
func (s *UserServiceRemote) GetUserByUsername(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "GetUserByUsername", p)
}


// ListUserApps via HTTP
// Generated from: @Route "GET /{user_id}/apps"
func (s *UserServiceRemote) ListUserApps(p *request.Context) ([]string, error) {
	return proxy.CallWithData[[]string](s.proxyService, "ListUserApps", p)
}


// ListUsers via HTTP
// Generated from: @Route "GET /"
func (s *UserServiceRemote) ListUsers(p *request.Context) ([]*domain.User, error) {
	return proxy.CallWithData[[]*domain.User](s.proxyService, "ListUsers", p)
}


// RemoveUserFromApp via HTTP
// Generated from: @Route "DELETE /{user_id}/remove-app"
func (s *UserServiceRemote) RemoveUserFromApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "RemoveUserFromApp", p)
}


// SuspendUser via HTTP
// Generated from: @Route "POST /{id}/suspend"
func (s *UserServiceRemote) SuspendUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "SuspendUser", p)
}


// UpdateUser via HTTP
// Generated from: @Route "PUT /{id}"
func (s *UserServiceRemote) UpdateUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "UpdateUser", p)
}



func UserServiceFactory(deps map[string]any, config map[string]any) any {
	return &UserService{
		AppService: service.Cast[*AppService](deps["app-service"]),
		TenantService: service.Cast[*TenantService](deps["tenant-service"]),
		UserAppStore: service.Cast[repository.UserAppStore](deps["user-app-store"]),
		Store: service.Cast[repository.UserStore](deps["user-store"]),
	}
}

// UserServiceRemoteFactory creates a remote HTTP client for UserServiceInterface
// Auto-generated from @RouterService annotation
func UserServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewUserServiceRemote(proxyService)
}

// RegisterUserService registers the user-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="user-service", prefix="/api/registration/tenants/{tenant_id}/users"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterUserService() {
	// Register service type with router configuration
	lokstra_registry.RegisterServiceType("user-service-factory",
		UserServiceFactory,
		UserServiceRemoteFactory,
		deploy.WithRouter(&deploy.ServiceTypeRouter{
			PathPrefix:  "/api/registration/tenants/{tenant_id}/users",
			Middlewares: []string{ "recovery", "request-logger" },
			CustomRoutes: map[string]string{
				"ActivateUser":  "POST /{id}/activate",
				"AssignUserToApp":  "POST /{user_id}/assign-app",
				"CreateUser":  "POST /",
				"DeleteUser":  "DELETE /{id}",
				"GetUser":  "GET /{id}",
				"GetUserByEmail":  "GET /by-email/{email}",
				"GetUserByUsername":  "GET /by-username/{username}",
				"ListUserApps":  "GET /{user_id}/apps",
				"ListUsers":  "GET /",
				"RemoveUserFromApp":  "DELETE /{user_id}/remove-app",
				"SuspendUser":  "POST /{id}/suspend",
				"UpdateUser":  "PUT /{id}",
			},
		}),
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("user-service",
		"user-service-factory",
		map[string]any{
			"depends-on": []string{ "app-service", "tenant-service", "user-app-store", "user-store",  },
		})
}


