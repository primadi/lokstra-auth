// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by lokstra-annotation from annotations in this folder
// Annotations: @RouterService, @Service, @Inject, @InjectCfgValue, @Route

package application

import (
	"github.com/primadi/lokstra/core/deploy"
	"github.com/primadi/lokstra/core/proxy"
	"github.com/primadi/lokstra/lokstra_registry"
	context "context"
	domain "github.com/primadi/lokstra-auth/core/domain"
	validator "github.com/primadi/lokstra-auth/credential/infrastructure/validator"
	repository "github.com/primadi/lokstra-auth/infrastructure/repository"
	request "github.com/primadi/lokstra/core/request"
)

// Auto-register on package import
func init() {
	RegisterAppKeyService()
	RegisterAppService()
	RegisterAuditLogService()
	RegisterBootstrapService()
	RegisterBranchService()
	RegisterCredentialConfigService()
	RegisterCredentialProviderService()
	RegisterIdentityLookupService()
	RegisterTenantService()
	RegisterUserIdentityService()
	RegisterUserService()
}

// ============================================================
// FILE: credential_config_service.go
// ============================================================

// CredentialConfigServiceRemote implements CredentialConfigServiceInterface with HTTP proxy
// Auto-generated from CredentialConfigService interface methods
type CredentialConfigServiceRemote struct {
	proxyService *proxy.Service
}

// NewCredentialConfigServiceRemote creates a new remote credential-config-service proxy
func NewCredentialConfigServiceRemote(proxyService *proxy.Service) *CredentialConfigServiceRemote {
	return &CredentialConfigServiceRemote{
		proxyService: proxyService,
	}
}

// GetAppConfig via HTTP
// Generated from: @Route "GET /apps/{app_id}"
func (s *CredentialConfigServiceRemote) GetAppConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "GetAppConfig", p)
}

// GetTenantConfig via HTTP
// Generated from: @Route "GET /"
func (s *CredentialConfigServiceRemote) GetTenantConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "GetTenantConfig", p)
}

// UpdateAppConfig via HTTP
// Generated from: @Route "PUT/apps/{app_id}"
func (s *CredentialConfigServiceRemote) UpdateAppConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "UpdateAppConfig", p)
}

// UpdateTenantConfig via HTTP
// Generated from: @Route "PUT /"
func (s *CredentialConfigServiceRemote) UpdateTenantConfig(p *request.Context) (*domain.CredentialConfig, error) {
	return proxy.CallWithData[*domain.CredentialConfig](s.proxyService, "UpdateTenantConfig", p)
}


func CredentialConfigServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &CredentialConfigService{
		AppService: deps["app-service"].(*AppService),
		TenantService: deps["tenant-service"].(*TenantService),
	}
	
	return svc
}

// CredentialConfigServiceRemoteFactory creates a remote HTTP client for CredentialConfigServiceInterface
// Auto-generated from @RouterService annotation
func CredentialConfigServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewCredentialConfigServiceRemote(proxyService)
}

// RegisterCredentialConfigService registers the credential-config-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="credential-config-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/config/credentials"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterCredentialConfigService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("credential-config-service-factory",
		CredentialConfigServiceFactory,
		CredentialConfigServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/config/credentials",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"GetAppConfig": {
					Path: "GET /apps/{app_id}",
				},
				"GetTenantConfig": {
					Path: "GET /",
				},
				"UpdateAppConfig": {
					Path: "PUT/apps/{app_id}",
				},
				"UpdateTenantConfig": {
					Path: "PUT /",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("credential-config-service",
		"credential-config-service-factory",
		map[string]any{
			"depends-on": []string{ "app-service", "tenant-service", },
		})
}


// ============================================================
// FILE: app_key_service.go
// ============================================================

// AppKeyServiceRemote implements AppKeyServiceInterface with HTTP proxy
// Auto-generated from AppKeyService interface methods
type AppKeyServiceRemote struct {
	proxyService *proxy.Service
}

// NewAppKeyServiceRemote creates a new remote app-key-service proxy
func NewAppKeyServiceRemote(proxyService *proxy.Service) *AppKeyServiceRemote {
	return &AppKeyServiceRemote{
		proxyService: proxyService,
	}
}

// DeleteKey via HTTP
// Generated from: @Route "DELETE /{key_id}"
func (s *AppKeyServiceRemote) DeleteKey(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteKey", p)
}

// GenerateKey via HTTP
// Generated from: @Route "POST /"
func (s *AppKeyServiceRemote) GenerateKey(p *request.Context) (*domain.AppKeyResponse, error) {
	return proxy.CallWithData[*domain.AppKeyResponse](s.proxyService, "GenerateKey", p)
}

// GetKey via HTTP
// Generated from: @Route "GET /{key_id}"
func (s *AppKeyServiceRemote) GetKey(p *request.Context) (*domain.AppKeyInfo, error) {
	return proxy.CallWithData[*domain.AppKeyInfo](s.proxyService, "GetKey", p)
}

// ListKeys via HTTP
// Generated from: @Route "GET /"
func (s *AppKeyServiceRemote) ListKeys(p *request.Context) ([]*domain.AppKeyInfo, error) {
	return proxy.CallWithData[[]*domain.AppKeyInfo](s.proxyService, "ListKeys", p)
}

// RevokeKey via HTTP
// Generated from: @Route "POST /{key_id}/revoke"
func (s *AppKeyServiceRemote) RevokeKey(p *request.Context) error {
	return proxy.Call(s.proxyService, "RevokeKey", p)
}

// RotateKey via HTTP
// Generated from: @Route "POST /{key_id}/rotate"
func (s *AppKeyServiceRemote) RotateKey(p *request.Context) (*domain.AppKeyResponse, error) {
	return proxy.CallWithData[*domain.AppKeyResponse](s.proxyService, "RotateKey", p)
}


func AppKeyServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &AppKeyService{
		AppService: deps["app-service"].(*AppService),
		Store: deps["@store.app-key-store"].(repository.AppKeyStore),
	}
	
	return svc
}

// AppKeyServiceRemoteFactory creates a remote HTTP client for AppKeyServiceInterface
// Auto-generated from @RouterService annotation
func AppKeyServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAppKeyServiceRemote(proxyService)
}

// RegisterAppKeyService registers the app-key-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="app-key-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/apps/{app_id}/keys"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterAppKeyService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("app-key-service-factory",
		AppKeyServiceFactory,
		AppKeyServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/apps/{app_id}/keys",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"DeleteKey": {
					Path: "DELETE /{key_id}",
				},
				"GenerateKey": {
					Path: "POST /",
				},
				"GetKey": {
					Path: "GET /{key_id}",
				},
				"ListKeys": {
					Path: "GET /",
				},
				"RevokeKey": {
					Path: "POST /{key_id}/revoke",
				},
				"RotateKey": {
					Path: "POST /{key_id}/rotate",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("app-key-service",
		"app-key-service-factory",
		map[string]any{
			"depends-on": []string{ "app-service", "@store.app-key-store", },
		})
}


// ============================================================
// FILE: app_service.go
// ============================================================

// AppServiceRemote implements AppServiceInterface with HTTP proxy
// Auto-generated from AppService interface methods
type AppServiceRemote struct {
	proxyService *proxy.Service
}

// NewAppServiceRemote creates a new remote app-service proxy
func NewAppServiceRemote(proxyService *proxy.Service) *AppServiceRemote {
	return &AppServiceRemote{
		proxyService: proxyService,
	}
}

// ActivateApp via HTTP
// Generated from: @Route "POST /{id}/activate"
func (s *AppServiceRemote) ActivateApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "ActivateApp", p)
}

// CreateApp via HTTP
// Generated from: @Route "POST /"
func (s *AppServiceRemote) CreateApp(p *request.Context) (*domain.App, error) {
	return proxy.CallWithData[*domain.App](s.proxyService, "CreateApp", p)
}

// DeleteApp via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *AppServiceRemote) DeleteApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteApp", p)
}

// GetApp via HTTP
// Generated from: @Route "GET /{id}"
func (s *AppServiceRemote) GetApp(p *request.Context) (*domain.App, error) {
	return proxy.CallWithData[*domain.App](s.proxyService, "GetApp", p)
}

// ListAppUsers via HTTP
// Generated from: @Route "GET /{app_id}/users"
func (s *AppServiceRemote) ListAppUsers(p *request.Context) ([]string, error) {
	return proxy.CallWithData[[]string](s.proxyService, "ListAppUsers", p)
}

// ListApps via HTTP
// Generated from: @Route "GET /"
func (s *AppServiceRemote) ListApps(p *request.Context) ([]*domain.App, error) {
	return proxy.CallWithData[[]*domain.App](s.proxyService, "ListApps", p)
}

// SuspendApp via HTTP
// Generated from: @Route "POST /{id}/suspend"
func (s *AppServiceRemote) SuspendApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "SuspendApp", p)
}

// UpdateApp via HTTP
// Generated from: @Route "PUT /{id}"
func (s *AppServiceRemote) UpdateApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "UpdateApp", p)
}


func AppServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &AppService{
		Store: deps["@store.app-store"].(repository.AppStore),
		UserAppStore: deps["@store.user-app-store"].(repository.UserAppStore),
		TenantService: deps["tenant-service"].(*TenantService),
	}
	
	return svc
}

// AppServiceRemoteFactory creates a remote HTTP client for AppServiceInterface
// Auto-generated from @RouterService annotation
func AppServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAppServiceRemote(proxyService)
}

// RegisterAppService registers the app-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="app-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/apps"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterAppService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("app-service-factory",
		AppServiceFactory,
		AppServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/apps",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"ActivateApp": {
					Path: "POST /{id}/activate",
				},
				"CreateApp": {
					Path: "POST /",
				},
				"DeleteApp": {
					Path: "DELETE /{id}",
				},
				"GetApp": {
					Path: "GET /{id}",
				},
				"ListAppUsers": {
					Path: "GET /{app_id}/users",
				},
				"ListApps": {
					Path: "GET /",
				},
				"SuspendApp": {
					Path: "POST /{id}/suspend",
				},
				"UpdateApp": {
					Path: "PUT /{id}",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("app-service",
		"app-service-factory",
		map[string]any{
			"depends-on": []string{ "@store.app-store", "@store.user-app-store", "tenant-service", },
		})
}


// ============================================================
// FILE: audit_log_service.go
// ============================================================

// AuditLogServiceRemote implements AuditLogServiceInterface with HTTP proxy
// Auto-generated from AuditLogService interface methods
type AuditLogServiceRemote struct {
	proxyService *proxy.Service
}

// NewAuditLogServiceRemote creates a new remote audit-log-service proxy
func NewAuditLogServiceRemote(proxyService *proxy.Service) *AuditLogServiceRemote {
	return &AuditLogServiceRemote{
		proxyService: proxyService,
	}
}

// CleanupOldAuditLogs via HTTP
// Generated from: @Route "POST /cleanup"
func (s *AuditLogServiceRemote) CleanupOldAuditLogs(p *request.Context) (*CleanupAuditLogsResponse, error) {
	return proxy.CallWithData[*CleanupAuditLogsResponse](s.proxyService, "CleanupOldAuditLogs", p)
}

// CreateAuditLog via HTTP
// Generated from: @Route "POST /"
func (s *AuditLogServiceRemote) CreateAuditLog(p *request.Context) (*domain.AuditLog, error) {
	return proxy.CallWithData[*domain.AuditLog](s.proxyService, "CreateAuditLog", p)
}

// GetAuditLog via HTTP
// Generated from: @Route "GET /{id}"
func (s *AuditLogServiceRemote) GetAuditLog(p *request.Context) (*domain.AuditLog, error) {
	return proxy.CallWithData[*domain.AuditLog](s.proxyService, "GetAuditLog", p)
}

// ListAuditLogs via HTTP
// Generated from: @Route "GET /"
func (s *AuditLogServiceRemote) ListAuditLogs(p *request.Context) (*ListAuditLogsResponse, error) {
	return proxy.CallWithData[*ListAuditLogsResponse](s.proxyService, "ListAuditLogs", p)
}


func AuditLogServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &AuditLogService{
		Store: deps["@store.audit-log-store"].(repository.AuditLogStore),
	}
	
	return svc
}

// AuditLogServiceRemoteFactory creates a remote HTTP client for AuditLogServiceInterface
// Auto-generated from @RouterService annotation
func AuditLogServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAuditLogServiceRemote(proxyService)
}

// RegisterAuditLogService registers the audit-log-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="audit-log-service", prefix="${api-auth-prefix:/api/auth}/core/audit/logs"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterAuditLogService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("audit-log-service-factory",
		AuditLogServiceFactory,
		AuditLogServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/audit/logs",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"CleanupOldAuditLogs": {
					Path: "POST /cleanup",
				},
				"CreateAuditLog": {
					Path: "POST /",
				},
				"GetAuditLog": {
					Path: "GET /{id}",
				},
				"ListAuditLogs": {
					Path: "GET /",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("audit-log-service",
		"audit-log-service-factory",
		map[string]any{
			"depends-on": []string{ "@store.audit-log-store", },
		})
}


// ============================================================
// FILE: bootstrap_service.go
// ============================================================

// BootstrapServiceRemote implements BootstrapServiceInterface with HTTP proxy
// Auto-generated from BootstrapService interface methods
type BootstrapServiceRemote struct {
	proxyService *proxy.Service
}

// NewBootstrapServiceRemote creates a new remote bootstrap-service proxy
func NewBootstrapServiceRemote(proxyService *proxy.Service) *BootstrapServiceRemote {
	return &BootstrapServiceRemote{
		proxyService: proxyService,
	}
}

// CreateTenantWithAdmin via HTTP
// Generated from: @Route "POST /"
func (s *BootstrapServiceRemote) CreateTenantWithAdmin(p context.Context) (*CreateTenantWithAdminResponse, error) {
	return proxy.CallWithData[*CreateTenantWithAdminResponse](s.proxyService, "CreateTenantWithAdmin", p)
}

// IsPlatformInitialized via HTTP
// Generated from: @Route "GET /status"
func (s *BootstrapServiceRemote) IsPlatformInitialized(p context.Context) (bool, error) {
	return proxy.CallWithData[bool](s.proxyService, "IsPlatformInitialized", p)
}


func BootstrapServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &BootstrapService{
		appRepo: deps["@store.app-store"].(repository.AppStore),
		tenantRepo: deps["@store.tenant-store"].(repository.TenantStore),
		userAppRepo: deps["@store.user-app-store"].(repository.UserAppStore),
		userRepo: deps["@store.user-store"].(repository.UserStore),
	}
	
	return svc
}

// BootstrapServiceRemoteFactory creates a remote HTTP client for BootstrapServiceInterface
// Auto-generated from @RouterService annotation
func BootstrapServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewBootstrapServiceRemote(proxyService)
}

// RegisterBootstrapService registers the bootstrap-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="bootstrap-service", prefix="${api-auth-prefix:/api/auth}/bootstrap"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterBootstrapService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("bootstrap-service-factory",
		BootstrapServiceFactory,
		BootstrapServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/bootstrap",
			Middlewares: []string{  },
			RouteOverrides: map[string]deploy.RouteConfig{
				"CreateTenantWithAdmin": {
					Path: "POST /",
				},
				"IsPlatformInitialized": {
					Path: "GET /status",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("bootstrap-service",
		"bootstrap-service-factory",
		map[string]any{
			"depends-on": []string{ "@store.app-store", "@store.tenant-store", "@store.user-app-store", "@store.user-store", },
		})
}


// ============================================================
// FILE: branch_service.go
// ============================================================

// BranchServiceRemote implements BranchServiceInterface with HTTP proxy
// Auto-generated from BranchService interface methods
type BranchServiceRemote struct {
	proxyService *proxy.Service
}

// NewBranchServiceRemote creates a new remote branch-service proxy
func NewBranchServiceRemote(proxyService *proxy.Service) *BranchServiceRemote {
	return &BranchServiceRemote{
		proxyService: proxyService,
	}
}

// ActivateBranch via HTTP
// Generated from: @Route "POST /{id}/activate"
func (s *BranchServiceRemote) ActivateBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "ActivateBranch", p)
}

// CreateBranch via HTTP
// Generated from: @Route "POST /"
func (s *BranchServiceRemote) CreateBranch(p *request.Context) (*domain.Branch, error) {
	return proxy.CallWithData[*domain.Branch](s.proxyService, "CreateBranch", p)
}

// DeleteBranch via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *BranchServiceRemote) DeleteBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteBranch", p)
}

// DisableBranch via HTTP
// Generated from: @Route "POST /{id}/disable"
func (s *BranchServiceRemote) DisableBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "DisableBranch", p)
}

// GetBranch via HTTP
// Generated from: @Route "GET /{id}"
func (s *BranchServiceRemote) GetBranch(p *request.Context) (*domain.Branch, error) {
	return proxy.CallWithData[*domain.Branch](s.proxyService, "GetBranch", p)
}

// ListBranches via HTTP
// Generated from: @Route "GET /"
func (s *BranchServiceRemote) ListBranches(p *request.Context) ([]*domain.Branch, error) {
	return proxy.CallWithData[[]*domain.Branch](s.proxyService, "ListBranches", p)
}

// UpdateBranch via HTTP
// Generated from: @Route "PUT /{id}"
func (s *BranchServiceRemote) UpdateBranch(p *request.Context) error {
	return proxy.Call(s.proxyService, "UpdateBranch", p)
}


func BranchServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &BranchService{
		AppService: deps["app-service"].(*AppService),
		Store: deps["@store.branch-store"].(repository.BranchStore),
	}
	
	return svc
}

// BranchServiceRemoteFactory creates a remote HTTP client for BranchServiceInterface
// Auto-generated from @RouterService annotation
func BranchServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewBranchServiceRemote(proxyService)
}

// RegisterBranchService registers the branch-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="branch-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/apps/{app_id}/branches"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterBranchService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("branch-service-factory",
		BranchServiceFactory,
		BranchServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/apps/{app_id}/branches",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"ActivateBranch": {
					Path: "POST /{id}/activate",
				},
				"CreateBranch": {
					Path: "POST /",
				},
				"DeleteBranch": {
					Path: "DELETE /{id}",
				},
				"DisableBranch": {
					Path: "POST /{id}/disable",
				},
				"GetBranch": {
					Path: "GET /{id}",
				},
				"ListBranches": {
					Path: "GET /",
				},
				"UpdateBranch": {
					Path: "PUT /{id}",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("branch-service",
		"branch-service-factory",
		map[string]any{
			"depends-on": []string{ "app-service", "@store.branch-store", },
		})
}


// ============================================================
// FILE: credential_provider_service.go
// ============================================================

// CredentialProviderServiceRemote implements CredentialProviderServiceInterface with HTTP proxy
// Auto-generated from CredentialProviderService interface methods
type CredentialProviderServiceRemote struct {
	proxyService *proxy.Service
}

// NewCredentialProviderServiceRemote creates a new remote credential-provider-service proxy
func NewCredentialProviderServiceRemote(proxyService *proxy.Service) *CredentialProviderServiceRemote {
	return &CredentialProviderServiceRemote{
		proxyService: proxyService,
	}
}

// CreateProvider via HTTP
// Generated from: @Route "POST /"
func (s *CredentialProviderServiceRemote) CreateProvider(p *request.Context) (*domain.CredentialProvider, error) {
	return proxy.CallWithData[*domain.CredentialProvider](s.proxyService, "CreateProvider", p)
}

// DeleteProvider via HTTP
// Generated from: @Route "DELETE /{provider_id}"
func (s *CredentialProviderServiceRemote) DeleteProvider(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteProvider", p)
}

// DisableProvider via HTTP
// Generated from: @Route "POST /{provider_id}/disable"
func (s *CredentialProviderServiceRemote) DisableProvider(p *request.Context) (*domain.CredentialProvider, error) {
	return proxy.CallWithData[*domain.CredentialProvider](s.proxyService, "DisableProvider", p)
}

// EnableProvider via HTTP
// Generated from: @Route "POST /{provider_id}/enable"
func (s *CredentialProviderServiceRemote) EnableProvider(p *request.Context) (*domain.CredentialProvider, error) {
	return proxy.CallWithData[*domain.CredentialProvider](s.proxyService, "EnableProvider", p)
}

// GetActiveProviderForApp via HTTP
// Generated from: @Route "GET /active"
func (s *CredentialProviderServiceRemote) GetActiveProviderForApp(p *request.Context) (*domain.CredentialProvider, error) {
	return proxy.CallWithData[*domain.CredentialProvider](s.proxyService, "GetActiveProviderForApp", p)
}

// GetProvider via HTTP
// Generated from: @Route "GET /{provider_id}"
func (s *CredentialProviderServiceRemote) GetProvider(p *request.Context) (*domain.CredentialProvider, error) {
	return proxy.CallWithData[*domain.CredentialProvider](s.proxyService, "GetProvider", p)
}

// GetProvidersByType via HTTP
// Generated from: @Route "GET /by-type/{provider_type}"
func (s *CredentialProviderServiceRemote) GetProvidersByType(p *request.Context) ([]*domain.CredentialProvider, error) {
	return proxy.CallWithData[[]*domain.CredentialProvider](s.proxyService, "GetProvidersByType", p)
}

// ListProviders via HTTP
// Generated from: @Route "GET /"
func (s *CredentialProviderServiceRemote) ListProviders(p *request.Context) ([]*domain.CredentialProvider, error) {
	return proxy.CallWithData[[]*domain.CredentialProvider](s.proxyService, "ListProviders", p)
}

// UpdateProvider via HTTP
// Generated from: @Route "PUT /{provider_id}"
func (s *CredentialProviderServiceRemote) UpdateProvider(p *request.Context) (*domain.CredentialProvider, error) {
	return proxy.CallWithData[*domain.CredentialProvider](s.proxyService, "UpdateProvider", p)
}


func CredentialProviderServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &CredentialProviderService{
		appStore: deps["@store.app-store"].(repository.AppStore),
		providerStore: deps["@store.credential-provider-store"].(repository.CredentialProviderStore),
		tenantStore: deps["@store.tenant-store"].(repository.TenantStore),
	}
	
	return svc
}

// CredentialProviderServiceRemoteFactory creates a remote HTTP client for CredentialProviderServiceInterface
// Auto-generated from @RouterService annotation
func CredentialProviderServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewCredentialProviderServiceRemote(proxyService)
}

// RegisterCredentialProviderService registers the credential-provider-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="credential-provider-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/credential-providers"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterCredentialProviderService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("credential-provider-service-factory",
		CredentialProviderServiceFactory,
		CredentialProviderServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/credential-providers",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"CreateProvider": {
					Path: "POST /",
				},
				"DeleteProvider": {
					Path: "DELETE /{provider_id}",
				},
				"DisableProvider": {
					Path: "POST /{provider_id}/disable",
				},
				"EnableProvider": {
					Path: "POST /{provider_id}/enable",
				},
				"GetActiveProviderForApp": {
					Path: "GET /active",
				},
				"GetProvider": {
					Path: "GET /{provider_id}",
				},
				"GetProvidersByType": {
					Path: "GET /by-type/{provider_type}",
				},
				"ListProviders": {
					Path: "GET /",
				},
				"UpdateProvider": {
					Path: "PUT /{provider_id}",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("credential-provider-service",
		"credential-provider-service-factory",
		map[string]any{
			"depends-on": []string{ "@store.app-store", "@store.credential-provider-store", "@store.tenant-store", },
		})
}


// ============================================================
// FILE: identity_lookup_service.go
// ============================================================

// IdentityLookupServiceRemote implements IdentityLookupServiceInterface with HTTP proxy
// Auto-generated from IdentityLookupService interface methods
type IdentityLookupServiceRemote struct {
	proxyService *proxy.Service
}

// NewIdentityLookupServiceRemote creates a new remote identity-lookup-service proxy
func NewIdentityLookupServiceRemote(proxyService *proxy.Service) *IdentityLookupServiceRemote {
	return &IdentityLookupServiceRemote{
		proxyService: proxyService,
	}
}

// FindUserByProvider via HTTP
// Generated from: @Route "GET /find-by-provider/{provider}/{provider_id}"
func (s *IdentityLookupServiceRemote) FindUserByProvider(p *request.Context) (*domain.UserWithIdentity, error) {
	return proxy.CallWithData[*domain.UserWithIdentity](s.proxyService, "FindUserByProvider", p)
}

// GetOrCreateUserByProvider via HTTP
// Generated from: @Route "POST /get-or-create"
func (s *IdentityLookupServiceRemote) GetOrCreateUserByProvider(p *request.Context) (*domain.UserWithIdentity, error) {
	return proxy.CallWithData[*domain.UserWithIdentity](s.proxyService, "GetOrCreateUserByProvider", p)
}


func IdentityLookupServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &IdentityLookupService{
		userIdentityStore: deps["@store.user-identity-store"].(repository.UserIdentityStore),
		userStore: deps["@store.user-store"].(repository.UserStore),
	}
	
	return svc
}

// IdentityLookupServiceRemoteFactory creates a remote HTTP client for IdentityLookupServiceInterface
// Auto-generated from @RouterService annotation
func IdentityLookupServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewIdentityLookupServiceRemote(proxyService)
}

// RegisterIdentityLookupService registers the identity-lookup-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="identity-lookup-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/identities"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterIdentityLookupService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("identity-lookup-service-factory",
		IdentityLookupServiceFactory,
		IdentityLookupServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/identities",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"FindUserByProvider": {
					Path: "GET /find-by-provider/{provider}/{provider_id}",
				},
				"GetOrCreateUserByProvider": {
					Path: "POST /get-or-create",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("identity-lookup-service",
		"identity-lookup-service-factory",
		map[string]any{
			"depends-on": []string{ "@store.user-identity-store", "@store.user-store", },
		})
}


// ============================================================
// FILE: tenant_service.go
// ============================================================

// TenantServiceRemote implements TenantServiceInterface with HTTP proxy
// Auto-generated from TenantService interface methods
type TenantServiceRemote struct {
	proxyService *proxy.Service
}

// NewTenantServiceRemote creates a new remote tenant-service proxy
func NewTenantServiceRemote(proxyService *proxy.Service) *TenantServiceRemote {
	return &TenantServiceRemote{
		proxyService: proxyService,
	}
}

// ActivateTenant via HTTP
// Generated from: @Route "POST /{id}/activate"
func (s *TenantServiceRemote) ActivateTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "ActivateTenant", p)
}

// CreateTenant via HTTP
// Generated from: @Route "POST /"
func (s *TenantServiceRemote) CreateTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "CreateTenant", p)
}

// DeleteTenant via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *TenantServiceRemote) DeleteTenant(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteTenant", p)
}

// GetTenant via HTTP
// Generated from: @Route "GET /{id}"
func (s *TenantServiceRemote) GetTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "GetTenant", p)
}

// ListTenants via HTTP
// Generated from: @Route "GET /"
func (s *TenantServiceRemote) ListTenants(p *request.Context) ([]*domain.Tenant, error) {
	return proxy.CallWithData[[]*domain.Tenant](s.proxyService, "ListTenants", p)
}

// SuspendTenant via HTTP
// Generated from: @Route "POST /{id}/suspend"
func (s *TenantServiceRemote) SuspendTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "SuspendTenant", p)
}

// UpdateTenant via HTTP
// Generated from: @Route "PUT /{id}"
func (s *TenantServiceRemote) UpdateTenant(p *request.Context) (*domain.Tenant, error) {
	return proxy.CallWithData[*domain.Tenant](s.proxyService, "UpdateTenant", p)
}


func TenantServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &TenantService{
		AppStore: deps["@store.app-store"].(repository.AppStore),
		Store: deps["@store.tenant-store"].(repository.TenantStore),
		UserAppStore: deps["@store.user-app-store"].(repository.UserAppStore),
		UserStore: deps["@store.user-store"].(repository.UserStore),
	}
	
	return svc
}

// TenantServiceRemoteFactory creates a remote HTTP client for TenantServiceInterface
// Auto-generated from @RouterService annotation
func TenantServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewTenantServiceRemote(proxyService)
}

// RegisterTenantService registers the tenant-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="tenant-service", prefix="${api-auth-prefix:/api/auth}/core/tenants"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterTenantService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("tenant-service-factory",
		TenantServiceFactory,
		TenantServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"ActivateTenant": {
					Path: "POST /{id}/activate",
				},
				"CreateTenant": {
					Path: "POST /",
				},
				"DeleteTenant": {
					Path: "DELETE /{id}",
				},
				"GetTenant": {
					Path: "GET /{id}",
				},
				"ListTenants": {
					Path: "GET /",
				},
				"SuspendTenant": {
					Path: "POST /{id}/suspend",
				},
				"UpdateTenant": {
					Path: "PUT /{id}",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("tenant-service",
		"tenant-service-factory",
		map[string]any{
			"depends-on": []string{ "@store.app-store", "@store.tenant-store", "@store.user-app-store", "@store.user-store", },
		})
}


// ============================================================
// FILE: user_identity_service.go
// ============================================================

// UserIdentityServiceRemote implements UserIdentityServiceInterface with HTTP proxy
// Auto-generated from UserIdentityService interface methods
type UserIdentityServiceRemote struct {
	proxyService *proxy.Service
}

// NewUserIdentityServiceRemote creates a new remote user-identity-service proxy
func NewUserIdentityServiceRemote(proxyService *proxy.Service) *UserIdentityServiceRemote {
	return &UserIdentityServiceRemote{
		proxyService: proxyService,
	}
}

// GetIdentity via HTTP
// Generated from: @Route "GET /{identity_id}"
func (s *UserIdentityServiceRemote) GetIdentity(p *request.Context) (*domain.UserIdentity, error) {
	return proxy.CallWithData[*domain.UserIdentity](s.proxyService, "GetIdentity", p)
}

// LinkIdentity via HTTP
// Generated from: @Route "POST /"
func (s *UserIdentityServiceRemote) LinkIdentity(p *request.Context) (*domain.UserIdentity, error) {
	return proxy.CallWithData[*domain.UserIdentity](s.proxyService, "LinkIdentity", p)
}

// ListIdentities via HTTP
// Generated from: @Route "GET /"
func (s *UserIdentityServiceRemote) ListIdentities(p *request.Context) ([]*domain.UserIdentity, error) {
	return proxy.CallWithData[[]*domain.UserIdentity](s.proxyService, "ListIdentities", p)
}

// UnlinkIdentity via HTTP
// Generated from: @Route "DELETE /{identity_id}"
func (s *UserIdentityServiceRemote) UnlinkIdentity(p *request.Context) error {
	return proxy.Call(s.proxyService, "UnlinkIdentity", p)
}

// UpdateIdentity via HTTP
// Generated from: @Route "PUT /{identity_id}"
func (s *UserIdentityServiceRemote) UpdateIdentity(p *request.Context) (*domain.UserIdentity, error) {
	return proxy.CallWithData[*domain.UserIdentity](s.proxyService, "UpdateIdentity", p)
}


func UserIdentityServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &UserIdentityService{
		userIdentityStore: deps["@store.user-identity-store"].(repository.UserIdentityStore),
		userStore: deps["@store.user-store"].(repository.UserStore),
	}
	
	return svc
}

// UserIdentityServiceRemoteFactory creates a remote HTTP client for UserIdentityServiceInterface
// Auto-generated from @RouterService annotation
func UserIdentityServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewUserIdentityServiceRemote(proxyService)
}

// RegisterUserIdentityService registers the user-identity-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="user-identity-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/users/{user_id}/identities"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterUserIdentityService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("user-identity-service-factory",
		UserIdentityServiceFactory,
		UserIdentityServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/users/{user_id}/identities",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"GetIdentity": {
					Path: "GET /{identity_id}",
				},
				"LinkIdentity": {
					Path: "POST /",
				},
				"ListIdentities": {
					Path: "GET /",
				},
				"UnlinkIdentity": {
					Path: "DELETE /{identity_id}",
				},
				"UpdateIdentity": {
					Path: "PUT /{identity_id}",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("user-identity-service",
		"user-identity-service-factory",
		map[string]any{
			"depends-on": []string{ "@store.user-identity-store", "@store.user-store", },
		})
}


// ============================================================
// FILE: user_service.go
// ============================================================

// UserServiceRemote implements UserServiceInterface with HTTP proxy
// Auto-generated from UserService interface methods
type UserServiceRemote struct {
	proxyService *proxy.Service
}

// NewUserServiceRemote creates a new remote user-service proxy
func NewUserServiceRemote(proxyService *proxy.Service) *UserServiceRemote {
	return &UserServiceRemote{
		proxyService: proxyService,
	}
}

// ActivateUser via HTTP
// Generated from: @Route "POST /id/{id}/activate"
func (s *UserServiceRemote) ActivateUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "ActivateUser", p)
}

// AssignUserToApp via HTTP
// Generated from: @Route "POST /id/{user_id}/assign-app"
func (s *UserServiceRemote) AssignUserToApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "AssignUserToApp", p)
}

// CreateUser via HTTP
// Generated from: @Route "POST /"
func (s *UserServiceRemote) CreateUser(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "CreateUser", p)
}

// DeleteUser via HTTP
// Generated from: @Route "DELETE /id/{id}"
func (s *UserServiceRemote) DeleteUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "DeleteUser", p)
}

// GetUser via HTTP
// Generated from: @Route "GET /id/{id}"
func (s *UserServiceRemote) GetUser(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "GetUser", p)
}

// GetUserByEmail via HTTP
// Generated from: @Route "GET /by-email/{email}"
func (s *UserServiceRemote) GetUserByEmail(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "GetUserByEmail", p)
}

// GetUserByUsername via HTTP
// Generated from: @Route "GET /by-username/{username}"
func (s *UserServiceRemote) GetUserByUsername(p *request.Context) (*domain.User, error) {
	return proxy.CallWithData[*domain.User](s.proxyService, "GetUserByUsername", p)
}

// ListUserApps via HTTP
// Generated from: @Route "GET /id/{id}/apps"
func (s *UserServiceRemote) ListUserApps(p *request.Context) ([]string, error) {
	return proxy.CallWithData[[]string](s.proxyService, "ListUserApps", p)
}

// ListUsers via HTTP
// Generated from: @Route "GET /"
func (s *UserServiceRemote) ListUsers(p *request.Context) ([]*domain.User, error) {
	return proxy.CallWithData[[]*domain.User](s.proxyService, "ListUsers", p)
}

// RemovePassword via HTTP
// Generated from: @Route "DELETE /id/{id}/password"
func (s *UserServiceRemote) RemovePassword(p *request.Context) error {
	return proxy.Call(s.proxyService, "RemovePassword", p)
}

// RemoveUserFromApp via HTTP
// Generated from: @Route "DELETE /id/{user_id}/remove-app"
func (s *UserServiceRemote) RemoveUserFromApp(p *request.Context) error {
	return proxy.Call(s.proxyService, "RemoveUserFromApp", p)
}

// SetPassword via HTTP
// Generated from: @Route "POST /id/{id}/password"
func (s *UserServiceRemote) SetPassword(p *request.Context) error {
	return proxy.Call(s.proxyService, "SetPassword", p)
}

// SuspendUser via HTTP
// Generated from: @Route "POST /id/{id}/suspend"
func (s *UserServiceRemote) SuspendUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "SuspendUser", p)
}

// UpdateUser via HTTP
// Generated from: @Route "PUT /id/{id}"
func (s *UserServiceRemote) UpdateUser(p *request.Context) error {
	return proxy.Call(s.proxyService, "UpdateUser", p)
}


func UserServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &UserService{
		AppService: deps["app-service"].(*AppService),
		Validator: deps["credential-validator"].(validator.CredentialValidator),
		UserAppStore: deps["@store.user-app-store"].(repository.UserAppStore),
		Store: deps["@store.user-store"].(repository.UserStore),
		TenantService: deps["tenant-service"].(*TenantService),
	}
	
	return svc
}

// UserServiceRemoteFactory creates a remote HTTP client for UserServiceInterface
// Auto-generated from @RouterService annotation
func UserServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewUserServiceRemote(proxyService)
}

// RegisterUserService registers the user-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="user-service", prefix="${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/users"
//   - @Inject annotations
//   - @Route annotations on methods
func RegisterUserService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("user-service-factory",
		UserServiceFactory,
		UserServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "${api-auth-prefix:/api/auth}/core/tenants/{tenant_id}/users",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"ActivateUser": {
					Path: "POST /id/{id}/activate",
				},
				"AssignUserToApp": {
					Path: "POST /id/{user_id}/assign-app",
				},
				"CreateUser": {
					Path: "POST /",
				},
				"DeleteUser": {
					Path: "DELETE /id/{id}",
				},
				"GetUser": {
					Path: "GET /id/{id}",
				},
				"GetUserByEmail": {
					Path: "GET /by-email/{email}",
				},
				"GetUserByUsername": {
					Path: "GET /by-username/{username}",
				},
				"ListUserApps": {
					Path: "GET /id/{id}/apps",
				},
				"ListUsers": {
					Path: "GET /",
				},
				"RemovePassword": {
					Path: "DELETE /id/{id}/password",
				},
				"RemoveUserFromApp": {
					Path: "DELETE /id/{user_id}/remove-app",
				},
				"SetPassword": {
					Path: "POST /id/{id}/password",
				},
				"SuspendUser": {
					Path: "POST /id/{id}/suspend",
				},
				"UpdateUser": {
					Path: "PUT /id/{id}",
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("user-service",
		"user-service-factory",
		map[string]any{
			"depends-on": []string{ "app-service", "credential-validator", "@store.user-app-store", "@store.user-store", "tenant-service", },
		})
}




