// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by lokstra-annotation from annotations in this folder
// Annotations: @RouterService, @Service, @Inject, @InjectCfgValue, @Route

package services

import (
	"github.com/primadi/lokstra/core/deploy"
	"github.com/primadi/lokstra/core/proxy"
	"github.com/primadi/lokstra/lokstra_registry"
	request "github.com/primadi/lokstra/core/request"
)

// Auto-register on package import
func init() {
	RegisterAdminService()
	RegisterDemoService()
	RegisterDocumentService()
	RegisterEditorService()
	RegisterProtectedService()
}

// ============================================================
// FILE: service.go
// ============================================================

// AdminServiceRemote implements AdminServiceInterface with HTTP proxy
// Auto-generated from AdminService interface methods
type AdminServiceRemote struct {
	proxyService *proxy.Service
}

// NewAdminServiceRemote creates a new remote admin-service proxy
func NewAdminServiceRemote(proxyService *proxy.Service) *AdminServiceRemote {
	return &AdminServiceRemote{
		proxyService: proxyService,
	}
}



// GetDashboard via HTTP
// Generated from: @Route "GET /dashboard"
func (s *AdminServiceRemote) GetDashboard(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetDashboard", p)
}







func AdminServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &AdminService{
	}
	
	return svc
}

// AdminServiceRemoteFactory creates a remote HTTP client for AdminServiceInterface
// Auto-generated from @RouterService annotation
func AdminServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewAdminServiceRemote(proxyService)
}

// RegisterAdminService registers the admin-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="admin-service", prefix="/api/admin"
//   - @Route annotations on methods
func RegisterAdminService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("admin-service-factory",
		AdminServiceFactory,
		AdminServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/admin",
			Middlewares: []string{ "recovery", "request_logger" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"DeleteDocument": {
					Path: "DELETE /{id}",
					Middlewares: []string{ "auth", "permission permission=document:delete" },
				},
				"GetContent": {
					Path: "GET /content",
					Middlewares: []string{ "auth", "any-role roles=editor,admin" },
				},
				"GetDashboard": {
					Path: "GET /dashboard",
					Middlewares: []string{ "auth", "role role=admin" },
				},
				"GetDocument": {
					Path: "GET /{id}",
					Middlewares: []string{ "auth", "permission permission=document:read" },
				},
				"GetInfo": {
					Path: "GET /info",
				},
				"GetProfile": {
					Path: "GET /profile",
				},
				"GetPublic": {
					Path: "GET /public",
				},
				"UpdateDocument": {
					Path: "POST /{id}",
					Middlewares: []string{ "auth", "permission permission=document:write" },
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("admin-service",
		"admin-service-factory",
		map[string]any{
		})
}


// ============================================================
// FILE: service.go
// ============================================================

// DemoServiceRemote implements DemoServiceInterface with HTTP proxy
// Auto-generated from DemoService interface methods
type DemoServiceRemote struct {
	proxyService *proxy.Service
}

// NewDemoServiceRemote creates a new remote demo-service proxy
func NewDemoServiceRemote(proxyService *proxy.Service) *DemoServiceRemote {
	return &DemoServiceRemote{
		proxyService: proxyService,
	}
}







// GetPublic via HTTP
// Generated from: @Route "GET /public"
func (s *DemoServiceRemote) GetPublic(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetPublic", p)
}



func DemoServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &DemoService{
	}
	
	return svc
}

// DemoServiceRemoteFactory creates a remote HTTP client for DemoServiceInterface
// Auto-generated from @RouterService annotation
func DemoServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewDemoServiceRemote(proxyService)
}

// RegisterDemoService registers the demo-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="demo-service", prefix="/api/demo"
//   - @Route annotations on methods
func RegisterDemoService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("demo-service-factory",
		DemoServiceFactory,
		DemoServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/demo",
			Middlewares: []string{  },
			RouteOverrides: map[string]deploy.RouteConfig{
				"DeleteDocument": {
					Path: "DELETE /{id}",
					Middlewares: []string{ "auth", "permission permission=document:delete" },
				},
				"GetContent": {
					Path: "GET /content",
					Middlewares: []string{ "auth", "any-role roles=editor,admin" },
				},
				"GetDashboard": {
					Path: "GET /dashboard",
					Middlewares: []string{ "auth", "role role=admin" },
				},
				"GetDocument": {
					Path: "GET /{id}",
					Middlewares: []string{ "auth", "permission permission=document:read" },
				},
				"GetInfo": {
					Path: "GET /info",
				},
				"GetProfile": {
					Path: "GET /profile",
				},
				"GetPublic": {
					Path: "GET /public",
				},
				"UpdateDocument": {
					Path: "POST /{id}",
					Middlewares: []string{ "auth", "permission permission=document:write" },
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("demo-service",
		"demo-service-factory",
		map[string]any{
		})
}


// ============================================================
// FILE: service.go
// ============================================================

// DocumentServiceRemote implements DocumentServiceInterface with HTTP proxy
// Auto-generated from DocumentService interface methods
type DocumentServiceRemote struct {
	proxyService *proxy.Service
}

// NewDocumentServiceRemote creates a new remote document-service proxy
func NewDocumentServiceRemote(proxyService *proxy.Service) *DocumentServiceRemote {
	return &DocumentServiceRemote{
		proxyService: proxyService,
	}
}

// DeleteDocument via HTTP
// Generated from: @Route "DELETE /{id}"
func (s *DocumentServiceRemote) DeleteDocument(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "DeleteDocument", p)
}



// GetDocument via HTTP
// Generated from: @Route "GET /{id}"
func (s *DocumentServiceRemote) GetDocument(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetDocument", p)
}




// UpdateDocument via HTTP
// Generated from: @Route "POST /{id}"
func (s *DocumentServiceRemote) UpdateDocument(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "UpdateDocument", p)
}


func DocumentServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &DocumentService{
	}
	
	return svc
}

// DocumentServiceRemoteFactory creates a remote HTTP client for DocumentServiceInterface
// Auto-generated from @RouterService annotation
func DocumentServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewDocumentServiceRemote(proxyService)
}

// RegisterDocumentService registers the document-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="document-service", prefix="/api/documents"
//   - @Route annotations on methods
func RegisterDocumentService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("document-service-factory",
		DocumentServiceFactory,
		DocumentServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/documents",
			Middlewares: []string{ "recovery", "request_logger" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"DeleteDocument": {
					Path: "DELETE /{id}",
					Middlewares: []string{ "auth", "permission permission=document:delete" },
				},
				"GetContent": {
					Path: "GET /content",
					Middlewares: []string{ "auth", "any-role roles=editor,admin" },
				},
				"GetDashboard": {
					Path: "GET /dashboard",
					Middlewares: []string{ "auth", "role role=admin" },
				},
				"GetDocument": {
					Path: "GET /{id}",
					Middlewares: []string{ "auth", "permission permission=document:read" },
				},
				"GetInfo": {
					Path: "GET /info",
				},
				"GetProfile": {
					Path: "GET /profile",
				},
				"GetPublic": {
					Path: "GET /public",
				},
				"UpdateDocument": {
					Path: "POST /{id}",
					Middlewares: []string{ "auth", "permission permission=document:write" },
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("document-service",
		"document-service-factory",
		map[string]any{
		})
}


// ============================================================
// FILE: service.go
// ============================================================

// EditorServiceRemote implements EditorServiceInterface with HTTP proxy
// Auto-generated from EditorService interface methods
type EditorServiceRemote struct {
	proxyService *proxy.Service
}

// NewEditorServiceRemote creates a new remote editor-service proxy
func NewEditorServiceRemote(proxyService *proxy.Service) *EditorServiceRemote {
	return &EditorServiceRemote{
		proxyService: proxyService,
	}
}


// GetContent via HTTP
// Generated from: @Route "GET /content"
func (s *EditorServiceRemote) GetContent(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetContent", p)
}








func EditorServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &EditorService{
	}
	
	return svc
}

// EditorServiceRemoteFactory creates a remote HTTP client for EditorServiceInterface
// Auto-generated from @RouterService annotation
func EditorServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewEditorServiceRemote(proxyService)
}

// RegisterEditorService registers the editor-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="editor-service", prefix="/api/editor"
//   - @Route annotations on methods
func RegisterEditorService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("editor-service-factory",
		EditorServiceFactory,
		EditorServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/editor",
			Middlewares: []string{ "recovery", "request_logger" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"DeleteDocument": {
					Path: "DELETE /{id}",
					Middlewares: []string{ "auth", "permission permission=document:delete" },
				},
				"GetContent": {
					Path: "GET /content",
					Middlewares: []string{ "auth", "any-role roles=editor,admin" },
				},
				"GetDashboard": {
					Path: "GET /dashboard",
					Middlewares: []string{ "auth", "role role=admin" },
				},
				"GetDocument": {
					Path: "GET /{id}",
					Middlewares: []string{ "auth", "permission permission=document:read" },
				},
				"GetInfo": {
					Path: "GET /info",
				},
				"GetProfile": {
					Path: "GET /profile",
				},
				"GetPublic": {
					Path: "GET /public",
				},
				"UpdateDocument": {
					Path: "POST /{id}",
					Middlewares: []string{ "auth", "permission permission=document:write" },
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("editor-service",
		"editor-service-factory",
		map[string]any{
		})
}


// ============================================================
// FILE: service.go
// ============================================================

// ProtectedServiceRemote implements ProtectedServiceInterface with HTTP proxy
// Auto-generated from ProtectedService interface methods
type ProtectedServiceRemote struct {
	proxyService *proxy.Service
}

// NewProtectedServiceRemote creates a new remote protected-service proxy
func NewProtectedServiceRemote(proxyService *proxy.Service) *ProtectedServiceRemote {
	return &ProtectedServiceRemote{
		proxyService: proxyService,
	}
}





// GetInfo via HTTP
// Generated from: @Route "GET /info"
func (s *ProtectedServiceRemote) GetInfo(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetInfo", p)
}

// GetProfile via HTTP
// Generated from: @Route "GET /profile"
func (s *ProtectedServiceRemote) GetProfile(p *request.Context) (any, error) {
	return proxy.CallWithData[any](s.proxyService, "GetProfile", p)
}




func ProtectedServiceFactory(deps map[string]any, config map[string]any) any {
	svc := &ProtectedService{
	}
	
	return svc
}

// ProtectedServiceRemoteFactory creates a remote HTTP client for ProtectedServiceInterface
// Auto-generated from @RouterService annotation
func ProtectedServiceRemoteFactory(deps, config map[string]any) any {
	proxyService, ok := config["remote"].(*proxy.Service)
	if !ok {
		panic("remote factory requires 'remote' (proxy.Service) in config")
	}
	return NewProtectedServiceRemote(proxyService)
}

// RegisterProtectedService registers the protected-service with the registry
// Auto-generated from annotations:
//   - @RouterService name="protected-service", prefix="/api/protected"
//   - @Route annotations on methods
func RegisterProtectedService() {
	// Register service type with router configuration
	lokstra_registry.RegisterRouterServiceType("protected-service-factory",
		ProtectedServiceFactory,
		ProtectedServiceRemoteFactory,
		&deploy.ServiceTypeConfig{
			PathPrefix:  "/api/protected",
			Middlewares: []string{ "recovery", "request_logger", "auth" },
			RouteOverrides: map[string]deploy.RouteConfig{
				"DeleteDocument": {
					Path: "DELETE /{id}",
					Middlewares: []string{ "auth", "permission permission=document:delete" },
				},
				"GetContent": {
					Path: "GET /content",
					Middlewares: []string{ "auth", "any-role roles=editor,admin" },
				},
				"GetDashboard": {
					Path: "GET /dashboard",
					Middlewares: []string{ "auth", "role role=admin" },
				},
				"GetDocument": {
					Path: "GET /{id}",
					Middlewares: []string{ "auth", "permission permission=document:read" },
				},
				"GetInfo": {
					Path: "GET /info",
				},
				"GetProfile": {
					Path: "GET /profile",
				},
				"GetPublic": {
					Path: "GET /public",
				},
				"UpdateDocument": {
					Path: "POST /{id}",
					Middlewares: []string{ "auth", "permission permission=document:write" },
				},
			},
		},
	)

	// Register lazy service with auto-detected dependencies
	lokstra_registry.RegisterLazyService("protected-service",
		"protected-service-factory",
		map[string]any{
		})
}


